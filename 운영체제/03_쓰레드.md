# 쓰레드

- Light Weight Process 라고도 함
- 프로세스 간에는 각 프로세스의 데이터 접근이 불가
- 하나의 프로세스에 여러개의 스레드 생성 가능
- 스레드들은 동시에 실행 가능
  - Thread는 각기 실행이 가능한 stack이 존재한다
- 프로세스 안에 있으므로, 프로세스의 데이터를 모두 접근 가능  

## :arrow_forward: Mulit Thread 
소프트웨어 병행 작업 처리를 위해 멀티스레드를 사용한다.  
최근 CPU는 멀티코어를 가지므로 쓰레드를 여러개 만들어 멀티 코어 활용도를 높인다.  

![mt](../img/multithread.PNG)  

<br>

## :arrow_forward: 쓰레드 장점
- 사용자에 대한 응답성 향상
- 자원 공유 효율
  - IPC 기법과 같이 프로세스간 자원 공유를 위해 번거로운 작업이 필요없음
  - 프로세스 안에 있으므로, 프로세스의 데이터를 모두 접근 가능
- 작업이 분리되어 코드가 간결  

<br>

## :arrow_forward: 쓰레드 단점
멀티 프로세스는 하나의 프로세스가 문제행겨도 다른 프로세스는 작동하지만,  

쓰레드는 한 쓰레드만 문제가 생겨도 전체 프로세스가 영향 받을 수 있다.  

- 쓰레드를 많이 생성하면 Context Switching이 많이 일어나 성능이 저하된다
  - 리눅스에서는 쓰레드를 프로세스처럼 다룬다
  - 쓰레드를 많이 생성하면 모든 쓰레드를 스케쥴링 해야하므로 Context Switchin이 많이 일어날 수 밖에 없다
<br>

## :arrow_forward: 쓰레드와 프로세스
- 프로세스는 독립적, 스레드는 프로세스의 서브셋
- 프로세스는 독립적인 자원을 가짐, 쓰레드는 프로세스 자원 공유
- 프로세스는 자신만의 주소영역 가짐, 쓰레드는 주소영역 공유
- 프로세스간에는 IPC 기법으로 통신하지만, 쓰레드는 필요 없음

<br>

## :arrow_forward: PThread
- POSIX 스레드(POSIX Threads, 약어 : PThread)
- Thread 관련 표준 API

<br>


## :arrow_forward: 동기화 (Synchronization)
- 작업들 사이에 실행 시기를 맞추는것
- 여러 스레드가 동일한 자원(데이터) 접근 시 동기화 이슈 발생
  - 동일 자원을 여러 스레드가 동시 수정시, 각 스레드 결과에 영향주는 것

동기화 이슈를 해결하려면 상호 배제를 활용(Mutual exclusion)  

쓰레드는 프로세스의 모든 데이터에 접근 가능하므로 여러 스레드가 변경하는 공유변수에 대해 Exclusive Access 가 필요하다.  

어느 한 스레드가 공유 변수를 갱신하는 동안 다른 스레드가 동시 접근하지 못하도록 해야한다.  


<br>

## :arrow_forward: Mutex , Semaphore

- Critical Section( 임계 구역)에 대한 접근을 막기 위해 LOCKING 메커니즘이 필요
  - Mutex(binary semaphore) : 임계구역에 하나의 스레드만 들어갈 수 있음
  - Semaphore : 임계구역에 여러 스레드가 들어갈 수 있음 
    - counter 를 두어서 동시에 리소스에 접근 할 수 있는 허용 가능한 스레드 수를 제어  



세마포어 (Semaphore)  
- P: 검사 (임계영역에 들어갈 때)
  - S 값이 1 이상이면, 임계 영역 진입 후, S값 1 차감 (S값이 0이면 대기)
- V: 증가 (임계영역에서 나올 때)
  - S 값을 1 더하고, 임계 영역을 나옴
- S: 세마포어 값 (초기 값만큼 여러 프로세스가 동시 임계 영역 접근 가능)


<br>

## :arrow_forward: 교착상태 (deadlock)
무한 대기 상태 : 두 개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에, 다음 단계로 진행하지 못하는 상태  

배치처리 시스템에서는 일어나지 않는 문제이지만 프로세스, 스레드 둘다 교착상태가 일어날 수 있음을 주의해야 하고 아래 네가지 경우에 교착상태 가능성이 있다.  

1. 상호배제(Mutual exclusion): 프로세스들이 필요로 하는 자원에 대해 배타적인 통제권을 요구한다.
2. 점유대기(Hold and wait): 프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다린다.
3. 비선점(No preemption): 프로세스가 어떤 자원의 사용을 끝낼 때까지 그 자원을 뺏을 수 없다.
4. 순환대기(Circular wait): 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있다.  

<br>

## :arrow_forward: 기아상태 (starvation)
특정 프로세스의 우선순위가 낮아서 원하는 자원을 계속 할당 받지 못하는 상태
교착상태와 기아상태  

교착상태는 여러 프로세스가 동일 자원 점유를 요청할 때 발생  

기아상태는 여러 프로세스가 부족한 자원을 점유하기 위해 경쟁할 때, 특정 프로세스는 영원히 자원 할당이 안되는 경우를 주로 의미함  

기아상태를 해결하려면 우선순위를 변경하여 각 프로세스가 높은 우선순위를 가질 기회를 주거나  

오래 기다린 프로세스의 우선순위를 높여주고, 요청 순서대로 처리하는 FIFO 기반 요청큐 사용하는 방법이 있다.  

