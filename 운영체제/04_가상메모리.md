# 가상메모리

여러 프로세스를 동시에 실행하면 각 프로세스마다 충분한 메모리를 할당하기에는 메모리 크기에 한계가 있다.  

이때 가상 메모리를 활용하여 프로세스간 공간을 분리시키고 하나의 프로세스 이슈가 전체 시스템에 영향을 주지 않도록 할 수 있다.  

<br>


## :arrow_forward: 가상메모리와 MMU

프로세스는 가상 주소를 사용하고, 실제 해당 주소에서 데이터를 읽고/쓸때 만 물리 주소로 바꿔주면된다.   

CPU 는 가상 메모리를 다루고, 실제 해당 주소 접근시 MMU 하드웨어 장치를 통해 물리 메모리 접근 한다.  

이때 하드웨어 장치를 이용해야 주소 변환이 빠르기 때문에 별도 장치를 둔다.  

- virtual address ( 가상 주소): 프로세스가 참조하는 주소
- physical address ( 물리 주소): 실제 메모리 주소
- MMU(Memory Management Unit) : CPU 에 코드 실행시, 가상 주소 메모리 접근이 필요할 때, 해당 주소를 물리 주소값으로 변환해주는 하드웨어 장치

<br>


## :arrow_forward: 페이징 시스템

페이징은 크기가 동일한 페이지로 가상 주소 공간과 이에 매칭하는 물리 주소공간을 관리하는 개념이다.  

하드웨어의 지원이 필요하고 리눅스에서는 4KB로 페이징 한다.  

페이지 번호를 기반으로 가상 주소/ 물리 주소 패밍 정보를 기록하고 사용한다.  

<br>

## :arrow_forward: 페이지 테이블

물리 주소에 있는 페이지 번호와 해당 페이지의 첫 물리 주소 정보를 매핑한 표  

프로세스에서 특정 가상 주소에 엑세스하려면 해당 프로세스의 페이지 테이블에 해당 가상주소가 포함된 페이지 번호가 있는지 확인하고 매핑정보를 알아낸다.  

CPU는 가상주소 접근시 MMU 하드웨어 장치를 통해 물리 메모리에 접근하고  

프로세스 생성시 페이지 테이블 정보를 생성한다.  

페이지 번호를 나타내는 bit를 구분하여 단계를 나누는 **다중 페이징 시스템** 도 있지만, 지금 당장은 이런게 있다는것만 알고 넘어가자.  

<br>

## :arrow_forward: MMU와 TLB(컴퓨터 구조)

MMU가 물리 주소를 확인하기 위해 메모리를 들럿다 와야 한다.
1. CPU에서 MMU에 가상주소를 요청한다
2. MMU는 메모리의 페이지 테이블에 접근한다.
3. 이때 메모리(페이지 테이블)에서 MMU에 물리주소를 요청한다.
4. 다시 MMU가 물리주소를 통해 메모리의 프로세스 페이지에 접근한다.
5. 마지막으로 프로세스페이지의 DATA를 CPU에 전달한다.

여기서 TLB(Translation Lookaside Buffer) = 페이지 정보 캐쉬를 이용해서 MMU와 TLB사이에 물리주소를 전달하고 캐싱한다.  

<br>

## :arrow_forward: 페이지 폴트

어떤 페이지가 실제 물리 메모리에 없을때 일어나는 인터럽트로  

운영체제가 페이지 폴트가 일어나면, 해당 페이지를 물리 메모리에 올린다.  

[pg](../img/pagefault.PNG)  


만약 페이지 폴트가 자주 일어난다면, 실행되기 전에 해당 페이지를 물리 메모리에 올려야 하지만 이 경우 시간이 오래걸린다.  

페이지 폴트를 방지하려면 향후 실행,참조될 코드와 데이터를 미리 물리 메모리에 올리면 되지만 이것도 모든 과정을 예측해야되므로 비현실적인 방법이다.

<Br>

## :arrow_forward: 페이지 교체 정책

운영체제가 특정 페이지를 물리 메모리에 올릴때 만약 물리 메모리가 이미 꽉 차있다면  

기존 페이지 중 하나를 물리 메모리에서 저장 매체로 내리고 새로운 페이지를 해당 물리 메모리 공간에 올린다.  

기존 메모리상의 어떤 페이지를 내릴것인가를 결정할때는 여러가지 알고리즘을 사용한다.  

- FIFO : 가장 먼저 들어온 페이지를 내린다.
- 최적 페이지 교체 알고리즘 (OPT) : 앞으로 사용하지 않을 페이지를 내린다. 
- LRU : 가장 오래전에 사용된 페이지를 내린다.
- LFU : 가장 적게 사용된 페이지를 내린다.  
- NUR : 최근에 사용되지 않은 페이지를 내리되 페이지마다 참조비트(R), 수정비트(M)을 둔다.  

여러개의 프로그램을 띄우면 반복적인 페이지 폴트가 발생(과도한 페이지 교체작업 발생)하여 실제로는 아무 작업도 하지 못하는 Thrashing 상태가 된다.  

이를 해결하기위해서는 램을 늘리는 아주 단순한 방법으로 해결할 수 있다.  

